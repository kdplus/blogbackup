---
title: Codeforces-R344
date: 2016-03-06 13:38:31
categories: algorithm
tags: [cf,c++]
---
## 吐槽
* 感觉是落选后就没写过题目
* 俞老板的机考还是给写错了
* 再一个是，没有任何理由不写题目啊...
* 只切水题...

## A.cpp
题意：两行数据找出最大的l,r区间，使得第一行该区间内数据按位或结果加第二行的该区间内按位或结果最大。
题解：按位或，越或结果越大。全区间就是答案。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 1e5 + 10;
const double eps = 1e-9;
long long n, now = 0, ans = 0, tmp;

int main()
{
	scanf("%I64d", &n);
	for(int i = 0; i < n; ++i) {
		scanf("%d", &tmp);
		now |= tmp;
	}
	ans += now;
	now = 0;
	for(int i = 0; i < n; ++i) {
		scanf("%d", &tmp);
		now |= tmp;
	}
	ans += now;
	printf("%I64d\n", ans);
	return 0;
}
```
## B.cpp
题意：一个矩阵可以按行或者列染色，会覆盖。打印最后的矩阵颜色。
题解：两个一位数组记录染色的操作，并记录是第几次染色，打印的时候比较列和行的染色优先度输出。
<!--more-->
```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 1e5 + 10;
const double eps = 1e-9;
long long n, m, k, rc, a;
int rOrc;
int row[5000 + 10][2], col[5000 + 10][2];

int main()
{
	cin >> n >> m >> k;
	for(int i = 1; i <= k; ++i){
		cin >> rOrc >> rc >> a;
		if(rOrc == 1) {
			row[rc - 1][0] = a;
			row[rc - 1][1] = i;
		} else {
			col[rc - 1][0] = a;
			col[rc - 1][1] = i;
		}
	}
	for(int i = 0; i < n; ++i){
		for(int j = 0; j < m; ++j){
			int color = row[i][1] > col[j][1] ? row[i][0] : col[j][0];
			cout << color << ' ';
		}
		cout << endl;
	}
	return 0;
}
```
